#ifndef _TENSORS_XH_
#define _TENSORS_XH_

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <pthread.h>

char edu_umn_cs_melt_exts_ableC_tensorAlgebra;

#ifdef TACO_PARALLEL
char edu_umn_cs_melt_exts_ableC_tensorAlgebra_parallel;

#ifdef TACO_THREADS
unsigned int edu_umn_cs_melt_exts_ableC_tensorAlgebra_threads = TACO_THREADS;
#endif

#endif


struct __attribute__((refId("edu:umn:cs:melt:exts:ableC:tensorAlgebra:tensor_acc"), module("edu:umn:cs:melt:exts:ableC:tensorAlgebra:tensor_acc"))) tensor_acc
{
  int x;
};

struct tensor_tree_s {
  char isLeaf;
  double val;
  unsigned long index;
  unsigned long numChildren;
  struct tensor_tree_s* children;
};

static void __free_tensor_tree(struct tensor_tree_s* t) {
  for(unsigned long i = 0; i < t->numChildren; i++) {
    __free_tensor_tree(&(t->children[i]));
  }
  if(t->numChildren >  0) free(t->children);
}

static void __free_tensor_packedTree(struct tensor_tree_s* t) {
  if(t->children > 0) {
    __free_tensor_packedTree(t->children);
    free(t->children);
  }
}

static char tensor_checkTree(struct tensor_tree_s* t) {
  if(t->isLeaf) return t->val != 0.0;
  unsigned long end = t->numChildren;
  for(unsigned long i = 0; i < end; i++) {
    if(tensor_checkTree(&(t->children[i]))) {
      return 1;
    }
  }
  return 0;
}

template<a>
a _read_rb(char* file) {
  fprintf(stderr, "Read RB is not currently supported.\n");
  exit(1);
  a res;
  return res;
}

template<a>
a _read_mtx(char* fileName) {
  FILE* file = fopen(fileName, "r");
  if(!file) {
    fprintf(stderr, "Could not open file '%s'\n", fileName);
    exit(1);
  }

  char data[32];
  char fmt[32];  
  char dataType;
  char formatType;

  if(fscanf(file, "%%%%MatrixMarket matrix coordinate %s %s\n", data, fmt) != 2) {
    fprintf(stderr, "File is not a MatrixMarket format\n");
    fclose(file);
    exit(1);
  }

  if(strcmp(data, "real") == 0) {
    dataType = 0;
  } else if(strcmp(data, "integer") == 0) {
    dataType = 1;
  } else if(strcmp(data, "complex") == 0) {
    fprintf(stderr, "Complex numbers are not supported in tensors\n");
    fclose(file);
    exit(1);
  } else {
    fprintf(stderr, "Data type specifier '%s' is not recognized.\n", data);
    fclose(file);
    exit(1);
  }
  
  if(strcmp(fmt, "general") == 0) {
    formatType = 0;
  } else if(strcmp(fmt, "symmetric") == 0) {
    formatType = 1;
  } else if(strcmp(fmt, "skew-symmetric") == 0) {
    formatType = 1;
  } else if(strcmp(fmt, "hermitian") == 0) {
    fprintf(stderr, "Complex numbers are not supported in tensors\n");
    fclose(file);
    exit(1);
  } else {
    fprintf(stderr, "Symmetry specifer '%s' is not recognized.\n", fmt);
    fclose(file);
    exit(1);
  }
 
  char* line = calloc(128, sizeof(char));
  
  fgets(line, 128, file);
  while(!feof(file) && line[0] == '%') {
    fgets(line, 128, file);
  }
  if(feof(file)) {
    fprintf(stderr, "End of MTX file reached without dimension specifier.\n");
    fclose(file);
    free(line);
    exit(1);
  }

  unsigned long rows, cols, entries;
  if(sscanf(line, "%lu %lu %lu", &rows, &cols, &entries) != 3) {
    fprintf(stderr, "Matrix size specifier line is not valid.\n");
    fclose(file);
    free(line);
    exit(1);
  }
  free(line);
  
  unsigned long arr[] = {rows, cols};
  a res = build(a)(arr);
  
  unsigned long r, c;
  double elem_d;
  long elem_i;

  unsigned long idx[] = {0, 0};

  for(unsigned long i = 0; i < entries; i++) {
    if(feof(file)) {
      fprintf(stderr, "End of file reached without finding appropriate number of elements\n");
      fclose(file);
      freeTensor(res);
      exit(1);
    }
    
    if(dataType == 0) {
      if(fscanf(file, "%lu %lu %le\n", &r, &c, &elem_d) != 3) {
        fprintf(stderr, "Element specifier is not correct format\n");
	fclose(file);
	freeTensor(res);
        exit(1);
      }
   
      idx[0] = r-1;
      idx[1] = c-1;
      res[idx] = elem_d;

      if(formatType == 1) {
        idx[0] = c-1;
	idx[1] = r-1;
        res[idx] = elem_d;
      }
    } else {
      if(fscanf(file, "%lu %lu %ld\n", &r, &c, &elem_i) != 3) {
        fprintf(stderr, "Element specifier is not correct format\n");
	fclose(file);
	freeTensor(res);
        exit(1);
      }
      
      idx[0] = r-1;
      idx[1] = c-1;
      res[idx] = elem_i;

      if(formatType == 1) {
        idx[0] = c-1;
	idx[1] = r-1;
        res[idx] = elem_i;
      }
    }
  }

  fclose(file);
  return res;
}

struct __new_elem {
  unsigned long* idx;
  double val;
  struct __new_elem* next;
};

template <a>
a _read_tns(char* fileName) {
  FILE* file = fopen(fileName, "r");
  if(!file) {
    fprintf(stderr, "Could not open file '%s'\n", fileName);
    exit(1);
  }

  unsigned long* dims = calloc(orderof(a), sizeof(unsigned long));
  
  struct __new_elem header = {0};

  double val;
  unsigned long* idx = calloc(orderof(a), sizeof(unsigned long));
  char* line = calloc(128, sizeof(char));

  fgets(line, 128, file);
  while(!feof(file)) {
    if(line[0] == '#') {;} 
    else {
      long bytes = 0;
      int newBytes = 0;
      for(unsigned long i = 0; i < orderof(a); i++) {
        if(sscanf(line + bytes, "%lu%n", idx + i, &newBytes) != 1) { // %n is number of bytes consumed. Not counted in return
	  fprintf(stderr, "Error in parsing .tns file, reached end of index before expected.\n");
	  fclose(file);
	  free(dims);
	  free(idx);
	  free(line);
	  
	  struct __new_elem* curr = header.next;
	  struct __new_elem* tmp;
	  while(curr) {
	    tmp = curr;
	    curr = tmp->next;
	    free(tmp->idx);
	    free(tmp);
	  }
	  
	  exit(1);
	}
	bytes += newBytes;

	if(idx[i] > dims[i]) dims[i] = idx[i];
	idx[i]--;
      }

      if(sscanf(line + bytes, "%le", &val) != 1) {
        fprintf(stderr, "Error in parsing .tns file, did not find floating point value\n");
	fclose(file);
	free(dims);
	free(idx);
	free(line);
	
	struct __new_elem* curr = header.next;
	struct __new_elem* tmp;
	while(curr) {
	  tmp = curr;
	  curr = tmp->next;
	  free(tmp->idx);
	  free(tmp);
	}

	exit(1);
      }

      struct __new_elem* elem = calloc(1, sizeof(struct __new_elem));
      elem->idx = calloc(orderof(a), sizeof(unsigned long));
      memcpy(elem->idx, idx, sizeof(unsigned long) * orderof(a));
      elem->val = val;
      elem->next = header.next;
      header.next = elem;
    }
    fgets(line, 128, file);
  }

  a res = build(a)(dims);

  struct __new_elem* curr = header.next;
  struct __new_elem* tmp;
  while(curr) {
    res[curr->idx] = curr->val;
    tmp = curr;
    curr = tmp->next;
    free(tmp->idx);
    free(tmp);
  }

  fclose(file);
  free(dims);
  free(idx);
  free(line);
  return res;
}

template<a>
a read(char* fileName) {
  int len = strlen(fileName);
  char* ext = fileName + len - 3;
  
  a res;
  if(strcmp(ext, "rb") == 0) {
    res = inst _read_rb<a>(fileName);
  } if(strcmp(ext, "mtx") == 0 || strcmp(ext, "ttx") == 0) {
    res = inst _read_mtx<a>(fileName);
  } else if(strcmp(ext, "tns") == 0) {
    res = inst _read_tns<a>(fileName);
  } else {
    fprintf(stderr, "Unknown file extension for tensor: %s\n", ext);
    exit(1);
  }
  
  return res;
}

#endif
