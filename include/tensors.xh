#ifndef _TENSORS_XH_
#define _TENSORS_XH_

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <pthread.h>

char edu_umn_cs_melt_exts_ableC_tensorAlgebra;

#ifdef TACO_PARALLEL
char edu_umn_cs_melt_exts_ableC_tensorAlgebra_parallel;

#ifdef TACO_THREADS
unsigned int edu_umn_cs_melt_exts_ableC_tensorAlgebra_threads = TACO_THREADS;
#endif

#endif


struct __attribute__((refId("edu:umn:cs:melt:exts:ableC:tensorAlgebra:tensor_acc"), module("edu:umn:cs:melt:exts:ableC:tensorAlgebra:tensor_acc"))) tensor_acc
{
  int x;
};

struct tensor_tree_s {
  char isLeaf;
  double val;
  unsigned long index;
  unsigned long numChildren;
  struct tensor_tree_s* children;
};

static void __free_tensor_tree(struct tensor_tree_s* t) {
  for(unsigned long i = 0; i < t->numChildren; i++) {
    __free_tensor_tree(&(t->children[i]));
  }
  if(t->numChildren >  0) free(t->children);
}

static void __free_tensor_packedTree(struct tensor_tree_s* t) {
  if(t->children > 0) {
    __free_tensor_packedTree(t->children);
    free(t->children);
  }
}

static char tensor_checkTree(struct tensor_tree_s* t) {
  if(t->isLeaf) return t->val != 0.0;
  unsigned long end = t->numChildren;
  for(unsigned long i = 0; i < end; i++) {
    if(tensor_checkTree(&(t->children[i]))) {
      return 1;
    }
  }
  return 0;
}

char _eq_str(char* str1, char* str2, int length) {
  for(int i = 0; i < length; i++) {
    if(str1[i] != str2[i]) return 0;
  }
  return 1;
}

char _is_whitespace(char c) {
  switch(c) {
    case ' ':
    case '\n':
    case '\t':
    case '\r':
      return 1;
    default:
      return 0;
  }
}

char _is_newline(char c) {
  switch(c) {
    case '\n':
    case '\r':
      return 1;
    default:
      return 0;
  }
}

char** _read_line(char* file) {
  char** res = malloc(sizeof(char*) * 2);
  if(file == 0) {
    res[0] = 0;
    res[1] = 0;
    return res;
  }
  
  int start = 0;
  while(file[start] != '\0' && _is_whitespace(file[start])) {
    start++;
  }
  if(file[start] == '\0') {
    res[0] = 0;
    res[1] = 0;
    return res;
  }
  
  res[0] = file + start;
  
  int length = start;
  while(file[length] != '\0' && !_is_newline(file[length])) {
    length++;
  }
  
  if(file[length] != '\0') {
    char* temp = malloc(sizeof(char) * (length - start + 1));
    memcpy(temp, res[0], sizeof(char) * (length - start));
    res[0] = temp;
    res[0][length - start] = '\0';
    
    res[1] = file + length + 1;
  } else {
    char* temp = malloc(sizeof(char) * (length - start));
    memcpy(temp, res[0], sizeof(char) * (length - start));
    res[0] = temp;
    res[1] = 0;
  }
  
  return res;
}

template<a>
a _read_rb(char* file) {
  fprintf(stderr, "Read RB is not currently supported.\n");
  exit(1);
  a res;
  return res;
}

template<a>
a _read_mtx(char* file) {
  char** lines = _read_line(file);
  char* header = lines[0];
  file = lines[1];

  char data[32];
  char fmt[32];  
  char dataType;
  char formatType;

  if(sscanf(header, "%%%%MatrixMarket matrix coordinate %s %s", data, fmt) != 2) {
    fprintf(stderr, "File is not a MatrixMarket format\n");
    exit(1);
  }

  if(strcmp(data, "real") == 0) {
    dataType = 0;
  } else if(strcmp(data, "integer") == 0) {
    dataType = 1;
  } else if(strcmp(data, "complex") == 0) {
    fprintf(stderr, "Complex numbers are not supported in tensors\n");
    exit(1);
  } else {
    fprintf(stderr, "Data type specifier is not recognized.\n");
    exit(1);
  }
  
  if(strcmp(fmt, "general") == 0) {
    formatType = 0;
  } else if(strcmp(fmt, "symmetric") == 0) {
    formatType = 1;
  } else if(strcmp(fmt, "skew-symmetric") == 0) {
    formatType = 1;
  } else if(strcmp(fmt, "hermitian") == 0) {
    fprintf(stderr, "Complex numbers are not supported in tensors\n");
    exit(1);
  } else {
    fprintf(stderr, "Symmetry specifer is not recognized.\n");
    exit(1);
  }
 
  free(lines[0]);
  free(lines);
  lines = _read_line(file);
  char* line = lines[0];
  file = lines[1];
  while(line[0] == '%') {
    free(lines[0]);
    free(lines);
    lines = _read_line(file);
    line = lines[0];
    file = lines[1];
  }
  
  unsigned long rows, cols, entries;
  if(sscanf(line, "%lu %lu %lu", &rows, &cols, &entries) != 3) {
    fprintf(stderr, "Matrix size specifier line is not valid.\n");
    exit(1);
  }
  
  unsigned long arr[] = {rows, cols};
  a res = build (a)(arr);
  
  unsigned long r, c;
  double elem_d;
  long elem_i;

  unsigned long idx[] = {0, 0};

  for(unsigned long i = 0; i < entries; i++) {
    free(lines[0]);
    free(lines);
    lines = _read_line(file);
    line = lines[0];
    file = lines[1];
    
    if(line == 0) {
      fprintf(stderr, "End of file reached without finding appropriate number of elements\n");
      exit(1);
    }
    
    if(dataType == 0) {
      if(sscanf(line, "%lu %lu %le", &r, &c, &elem_d) != 3) {
        fprintf(stderr, "Element specifier is not correct format\n");
        exit(1);
      }
   
      idx[0] = r-1;
      idx[1] = c-1;
      res[idx] = elem_d;
      if(formatType == 1) {
        idx[0] = c-1;
	idx[1] = r-1;
        res[idx] = elem_d;
      }
    } else {
      if(sscanf(line, "%lu %lu %ld", &r, &c, &elem_i) != 3) {
        fprintf(stderr, "Element specifier is not correct format\n");
        exit(1);
      }
      
      idx[0] = r-1;
      idx[1] = c-1;
      res[idx] = elem_i;
      if(formatType == 1) {
        idx[0] = c-1;
	idx[1] = r-1;
        res[idx] = elem_i;
      }
    }
  }
  free(lines[0]);
  free(lines);
  
  return res;
}

template <a>
a _read_tns(char* file) {
  char** lines = _read_line(file);
  unsigned long* dims = calloc(orderof(a), sizeof(unsigned long));
  for(unsigned long i = 0; i < orderof(a); i++) {
    dims[i] = 1;
  }
  
  a res = build(a)(dims);
  free(dims);
  dims = res.dims;

  unsigned long* idx = calloc(orderof(a), sizeof(unsigned long));
  unsigned long* zeroIdx = calloc(orderof(a), sizeof(unsigned long));
  
  char* line;
  double val;
  char changed = 0;
  while(lines[0] != 0) {
    line = lines[0];
    file = lines[1];

    if(line[0] != '#') {
      changed = 0;
      for(unsigned long i = 0; i < orderof(a); i++) {
        if(sscanf(line, "%lu", idx + i) != 1) {
	  fprintf(stderr, "Error in parsing .tns file, reached end of index before expected.\n");
	  exit(1);
	}
	
	if(idx[i] > dims[i]) {
	  dims[i] = idx[i];
	  changed = 1;
	}
	idx[i]--;

	while(!_is_whitespace(line[0])) line++;
	while(_is_whitespace(line[0])) line++;
      }
      if(changed) res[zeroIdx]; // Pack tensor

      if(sscanf(line, "%le", &val) != 1) {
        fprintf(stderr, "Error in parsing .tns file, did not find floating point value\n");
	exit(1);
      }
      res[idx] = val;
    }

    free(lines[0]);
    free(lines);
    lines = _read_line(file);
  }

  free(lines[0]);
  free(lines);
  free(idx);
  free(zeroIdx);

  return res;
}

template<a>
a read(char* fileName) {
  int len = strlen(fileName);
  char* ext = fileName + len - 3;
  
  int fd = open(fileName, O_RDONLY);
  struct stat stat_buf;
  fstat(fd, &stat_buf);
  int size = stat_buf.st_size;
  char *file = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
  
  a res;
  if(_eq_str(ext, "rb", 2)) {
    res = inst _read_rb<a>(file);
  } if(_eq_str(ext, "mtx", 3) || _eq_str(ext, "ttx", 3)) {
    res = inst _read_mtx<a>(file);
  } else if(_eq_str(ext, "tns", 3)) {
    res = inst _read_tns<a>(file);
  } else {
    fprintf(stderr, "Unknown file extension for tensor: %s\n", ext);
    exit(1);
  }
  
  munmap(file, size);
  close(fd);

  return res;
}

#endif
